@* ReSharper disable once InconsistentNaming *@

@code {
	/// <summary>
	/// Default render fragment used when routing hits the vault's root.
	/// </summary>
	/// <returns>A default render fragment, which simply lists the vault's content inside <c>ul</c> elements.</returns>
	internal static RenderFragment Render(IVault vault) => __builder =>
	{
		<nav name="@vault.Name">
			<h1>@vault.Name</h1>
			
			@* Display a hierarchical view of all Markdown files, ranged by subfolders. *@
			@FolderNavigationTree(vault.Root, true)
		</nav>
	};
	
	private static @RenderFragment FolderNavigationTree(IVaultFolder folder, bool isRoot = false) => __builder =>
	{
		// Merge all subfolders and files into a single list.
		IOrderedEnumerable<KeyValuePair<string, IVaultEntity>> items = folder.Subfolders
			.Where(f => !isRoot || f.Name != ".obsidian")
			.Cast<IVaultEntity>()
			.Concat(folder.Files)
			.Select(x => new KeyValuePair<string, IVaultEntity>(x.Path, x))
			.OrderBy(x => x.Key);

		// Display the list.
		
		<ul>
			@foreach (KeyValuePair<string, IVaultEntity> item in items)
			{
				@if(item.Value is IVaultFolder subfolder)
				{
					<li>
						<a href="@subfolder.Path/">@subfolder.Name</a>
						@FolderNavigationTree(subfolder)
					</li>
				}
				else if (item.Value is IVaultNote file)
				{
					// The file's path should be filtered to remove the file's extension (".md").
					<li>
						<a href="@(file.Path[..^3])">@file.Name[..^3]</a>
					</li>
				}
			}
		</ul>
	};
}